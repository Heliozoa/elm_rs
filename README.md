Automatically generate type definitions and functions for your Elm frontend from your Rust backend types. Currently supports generating
- Elm types with the `Elm` trait and derive macro
- JSON encoders and decoders, compatible with `serde` and `serde_json`, with the `ElmJson` trait and derive macro
- Multipart form requests that can be parsed by Rocket's `FromForm` with the `ElmForm` and `ElmFormParts` traits and derive macros

### Usage
For example, the following code
```rust
use jalava::{Elm, ElmForm, ElmFormParts, ElmJson};

#[derive(Elm, ElmJson, ElmFormParts)]
enum Filetype {
    Jpeg,
    Png,
}

#[derive(Elm, ElmJson, ElmForm)]
struct Drawing {
    title: String,
    authors: Vec<String>,
    filename: String,
    filetype: Filetype,
}

fn main() {
    // the target would typically be a file
    let mut target = vec![];
    // jalava provides a macro for conveniently creating an Elm module with everything needed
    jalava::export!("Bindings", &mut target, Drawing, Filetype; Drawing).unwrap();
    let output = String::from_utf8(target).unwrap();
    println!("{}", output);
}
```
prints out
```elm
-- GENERATED BY JALAVA


module Bindings exposing (..)

import Dict exposing (Dict)
import File
import Http
import Json.Decode
import Json.Encode


boolToString : Bool -> String
boolToString b =
    case b of
        True ->
            "True"

        False ->
            "False"


type alias Drawing =
    { title : String
    , authors : List (String)
    , filename : String
    , filetype : Filetype
    }


drawingEncoder : Drawing -> Json.Encode.Value
drawingEncoder struct =
    Json.Encode.object
        [ ( "title", (Json.Encode.string) struct.title )
        , ( "authors", (Json.Encode.list (Json.Encode.string)) struct.authors )
        , ( "filename", (Json.Encode.string) struct.filename )
        , ( "filetype", (filetypeEncoder) struct.filetype )
        ]


drawingDecoder : Json.Decode.Decoder Drawing
drawingDecoder =
    Json.Decode.succeed Drawing
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.oneOf [ Json.Decode.field "title" (Json.Decode.string) ]))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.oneOf [ Json.Decode.field "authors" (Json.Decode.list (Json.Decode.string)) ]))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.oneOf [ Json.Decode.field "filename" (Json.Decode.string) ]))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.oneOf [ Json.Decode.field "filetype" (filetypeDecoder) ]))


type Filetype
    = Jpeg
    | Png


filetypeEncoder : Filetype -> Json.Encode.Value
filetypeEncoder enum =
    case enum of
        Jpeg ->
            Json.Encode.string "Jpeg"
        Png ->
            Json.Encode.string "Png"

filetypeDecoder : Json.Decode.Decoder Filetype
filetypeDecoder = 
    Json.Decode.oneOf
        [ Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "Jpeg" ->
                            Json.Decode.succeed Jpeg
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        , Json.Decode.string
            |> Json.Decode.andThen
                (\x ->
                    case x of
                        "Png" ->
                            Json.Decode.succeed Png
                        unexpected ->
                            Json.Decode.fail <| "Unexpected variant " ++ unexpected
                )
        ]

prepareDrawing : Drawing -> Http.Body
prepareDrawing form =
    Http.multipartBody <|
        List.concat
            [ [ Http.stringPart ("title") (identity form.title) ]
            , List.concat (List.concat (List.indexedMap (\i0 x0 -> [ [ Http.stringPart ("authors[" ++ String.fromInt i0 ++ "]") (identity x0) ] ]) (identity form.authors)))
            , [ Http.stringPart ("filename") (identity form.filename) ]
            , [ Http.stringPart "filetype" (filetypeToString form.filetype) ]
            ]


```

### Cargo features
- jalava-derive: Activated by default. Enables deriving the `Elm` and `ElmJson` (and `ElmForm` with rocket-compat) traits.
- serde-compat: Enables compatibility with many of serde's attributes.
- rocket-compat: Enables the `ElmForm` and `ElmFormParts` trait which allow easy integration with Rocket's forms.

### Serde compatibility
The `serde-compat` feature enables compatibility with serde attributes. Currently the following attributes are supported:
#### Container attributes
- rename_all
- tag
- tag & content
- untagged
- transparent
#### Variant attributes
- rename
- rename_all
- skip
- other
#### Field attributes
- rename
- skip

### 0.1.0
- [x] Generate Elm types with the `Elm` trait and derive macro
- [x] Generate JSON encoders and decoders with the `ElmJson` trait and derive macro
- [x] Generate Elm functions that create multipart requests compatible with Rocket's multipart form parsing through the `rocket::{ElmForm, ElmFormField}` traits and derive macros
- [x] Basic generic support
- [x] Compatibility with most serde attributes

### Planned
- [ ] Compatibility with more complicated serde attributes
  - [ ] flatten
  - [ ] alias
  - [ ] skip_(de)serializing
- [ ] Optionally include definitions for the dependencies of exported types
- [ ] Implement support for more `serde::{Deserialize, Serialize}` std types
  - [ ] IpAddr, Ipv4Addr, Ipv6Addr
  - [ ] SocketAddr, SocketAddrV4, SocketAddrV6
  - [ ] PhantomData
- [ ] Handle recursive types
- [ ] Improve generic support
- [ ] Compatibility with rocket attributes (e.g. `field`)
- [ ] Attributes for controlling the name of the Elm type etc.

### License
Licensed under either one of
- Apache License, Version 2.0
- The MIT License
