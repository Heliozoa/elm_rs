#![doc = include_str!("../../README.md")]

mod elm;
mod json;
#[cfg(feature = "with-rocket")]
mod rocket;
#[cfg(test)]
mod test;

#[cfg(test)]
extern crate self as jalava;

#[cfg(feature = "with-rocket")]
pub use self::rocket::{ElmForm, ElmFormParts};
pub use self::{elm::Elm, json::ElmJson};

#[macro_export]
/// Writes an Elm module to the target. Assumes `elm/json`, `elm/http` and `elm/file` are installed.
///
/// # Example
/// ```no_run
/// # #[derive(jalava::Elm, jalava::ElmJson)]
/// # struct MyStruct { s: String }
/// # #[derive(jalava::Elm, jalava::ElmForm)]
/// # struct MyForm { s: String }
/// let mut file = std::fs::File::create("MyModule.elm").unwrap();
/// jalava::export!("MyModule", &mut file, MyStruct; MyForm).unwrap();
/// ```
macro_rules! export {
    ($name: expr, $target: expr $(, $json: ty)* $(; $($form: ty),* $(,)?)?) => {
        {
            fn _export(name: &::std::primitive::str, target: &mut impl ::std::io::Write) -> ::std::result::Result<(), ::std::io::Error> {
                let mut defined = ::std::collections::HashSet::<::std::any::TypeId>::new();

                ::std::writeln!(target, "\
-- GENERATED BY JALAVA


module {} exposing (..)

import Dict exposing (Dict)
import File
import Http
import Json.Decode
import Json.Encode


boolToString : Bool -> String
boolToString b =
    case b of
        True ->
            \"True\"

        False ->
            \"False\"

", name)?;
                $(
                    if let ::std::option::Option::Some(elm_definition) = <$json as $crate::Elm>::elm_definition() {
                        defined.insert(::std::any::TypeId::of::<$json>());
                        ::std::writeln!(target, "{}\n", elm_definition)?;
                    }
                    if let ::std::option::Option::Some(encoder_definition) = <$json as $crate::ElmJson>::encoder_definition() {
                        ::std::writeln!(target, "{}\n", encoder_definition)?;
                    }
                    if let ::std::option::Option::Some(decoder_definition) = <$json as $crate::ElmJson>::decoder_definition() {
                        ::std::writeln!(target, "{}\n", decoder_definition)?;
                    }
                )*
                $($(
                    if !defined.contains(&::std::any::TypeId::of::<$form>()) {
                        if let ::std::option::Option::Some(elm_definition) = <$form as $crate::Elm>::elm_definition() {
                            ::std::writeln!(target, "{}\n", elm_definition)?;
                        }
                    }
                    ::std::writeln!(target, "{}\n", <$form as $crate::ElmForm>::prepare_form())?;
                )*)?
                ::std::result::Result::Ok(())
            }
            _export($name, $target)
        }
    };
}
